---
title: "CRISPRi library additional tests"
output: html_notebook
---


## Description

The purpose of this R markdown notebook is to provide a trackable, reproducible,
and comprehensive documentation of data processing steps for experiments carried 
out using a CRISPRi sgRNA library in the  cyanobacterium _Synechocystis_ sp. PCC6803.

This is an additional part of the pipeline where other tracks are explored by
blending the fitness results of the CRISPRi library with protein abundance
or protein variability. The additional data set used here is a proteomics study 
from [Jahn et al., Cell Reports, 2018](https://linkinghub.elsevier.com/retrieve/pii/S2211124718314852).
The idea is that gene/protein essentiality could correlate with variability in
protein abundance. One scenario would be that 'core proteins' are both essential and
less variable in abundance as they are required under all possible conditions.
The 'core proteome' (around 400 proteins in _E. coli_) was reported to  be mostly
allosterically regulated instead of transcriptionally.


```{r, results = 'hide', message = FALSE}
# LOAD PACKAGES

library(lattice)
library(latticeExtra)
library(grid)
library(tidyverse)
library(Rtools)
```


## Correlation between gene fitness and gene expression variability

Preprocessed data in the form of reads per gene was summarized and annotated 
in pipeline 1. It includes mean read fraction, log2 FC and p-value calculated 
using DESeq2. Genome annotation was added based on uniprot and cyanobase annotation
of the reference genome for _Synechocystis_ sp. PCC6803. 

----------

#### Loading and merging proteomics data

```{r, message = FALSE, warning = FALSE}
# load CRISPRi library data
load(file = "../processed_data/CRISPRi_library_df_cluster.Rdata")

# exclude ncRNAs from analysis
df_all <- df
df <- df %>% filter(!grepl("^Entry", sgRNA))
```


```{r, message = FALSE, warning = FALSE}
# load MS data from Cell Reports paper and combine with library
df_ms <- read_csv("../../../../../Experiments/20171204_MS_CO2/CO2_light/analysis/diffacto_weightedsum/df_long_massfrac.csv") %>%
  
  # we can try both light and CO2-related regulation (one ANOVA test per limitation and protein)
  # -------------------------
  # this block is for LIGHT
  # -------------------------
  #filter(sample == "light", light %in% c(300, 100)) %>%
  
  # change sample annotation from [100, 300] to [L100, L300]
  #mutate(condition = recode(light, `300` = "L300", `100` = "L100")) %>%
  
  # rename a column
  #rename(locus = protein) %>%
  
  # select only the interesting columns
  #select(locus, condition, mean.mass.fraction.norm, ANOVA, ANOVA.adj) %>%
  
  # -------------------------
  # this block is for CO2
  # -------------------------
  filter(sample == "CO2", concentration == 1) %>% 
  
  # rename a column
  rename(locus = protein) %>%
  
  # select only the interesting columns
  select(locus, mean.mass.fraction.norm, ANOVA, ANOVA.adj) %>%
  # -------------------------
  
  # merge with df
  left_join(df, .) %>%
  
  # filter for L100 and L300 only
  filter(condition %in% c("L100", "L300"))

  
# test if mass fraction sums up to _around 1_ (also depends on intersection
# between proteomics and CRISPRi library gene sets)
df_ms %>% group_by(condition, timepoint, induction, sgRNA_index) %>% 
  summarise(sum(mean.mass.fraction.norm, na.rm = TRUE)) %>% head


# # optionally reduce data to only the most 
# df_ms <- df_ms %>% group_by(condition, induction, sgRNA_short) %>%
# summarise(
#   fitness_score = min(fitness_score),
#   ANOVA.adj = min(ANOVA.adj)
# )

```

----------

#### Correlation between change over light conditions and essentiality

Different metrics could be used to determine a the extent of a protein changing 
abundance over light conditions. The MS dataset contains an ANOVA p-value that is 
lower (more significant) the more a protein changes abudnance over light intensity/
growth rate (5 light intensities were originally tested: L60, L100, L200, L300 
and L1000). The p-value obtained from ANOVA is the same for all conditions. It is
therefore not neccessary to include all possible light conditions. If all sgRNAs 
are mapped to their corresponding proteins (2 sgRNAs per protein), no correlation is
visible. Also not, if optionally only the more depleted of the two sgRNAs per protein
are selected.

```{r, fig.width = 6, fig.height = 3.5}
# filter dataset for 1 time point only (fitness score is identical
# for all time points of 1 condition)
df_ms %>% filter(timepoint == 0) %>%
  
  xyplot(-log10(ANOVA.adj) ~ fitness_score | factor(condition, unique(condition)), .,
  as.table = TRUE, groups = induction, 
  between = list(x = 0.5, y = 0.5),
  par.settings = custom.lattice, pch = 19, cex = 0.3,
  scales = list(alternating = FALSE),
  #xlim = c(-9, 4), ylim = c(-9, 4),
  xlab = "fitness", ylab = "ANOVA -log10 p-value",
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.xyplot(x, y, ... )
    panel.key(c("induced", "uninduced"), pch = 19, corner = c(0.1, 0.9))
  }
)
```

However it is possible to refine the approach by selecting subsets of sgRNAs or 
proteins. In the following step, proteins are binned by ANOVA log10 -p-value,
and fitness score distribution evaluated as box and whisker plot. Here, a trend
can be seen in the form of more significantly regulated genes (higher -log10 p-value)
having reduced median fitness.

```{r, fig.width = 5, fig.height = 4}
# customize plotting colors a bit
custom.lattice <- custom.lattice()
custom.lattice$box.rectangle$col = rep(c("#CC476B", "#00526D"), c(3,2))
custom.lattice$box.umbrella$col = rep(c("#CC476B", "#00526D"), c(3,2))
custom.lattice$box.rectangle$lwd = 1.5
custom.lattice$box.umbrella$lwd = 1.5


# filter dataset for 1 time point only (fitness score is identical
# for all time points of 1 condition)
plot_fitness_ANOVA_bw <- df_ms %>% filter(timepoint == 0) %>%
  
  # bin into groups by -log10 p-value
  mutate(ANOVA_bin = cut(ANOVA.adj, breaks = c(1,0.1,0.05,0.01,0.001,0))) %>%
  
  xyplot(fitness_score ~ factor(ANOVA_bin) | factor(condition) %>% 
      paste0(" - ", recode(induction, i = "induced", u = "uninduced")), .,
    as.table = TRUE, between = list(x = 0.5, y = 0.5),
    par.settings = custom.lattice, lwd = 1.5, 
    scales = list(alternating = FALSE, x = list(rot = 30, cex = 0.7)),
    xlab = "ANOVA -log10 p-value", ylab = "fitness",
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.violin(x, y, horizontal = FALSE, border = NA, col = grey(0.7, 0.5))
      panel.bwplot(x, y, horizontal = FALSE, pch = "|", do.out = FALSE, ... )
      panel.pvalue(x, y, fixed_pos = -1, std = 5, 
        col = rep(c("#CC476B", "#00526D"), c(3,2))
      )
    }
  )

print(plot_fitness_ANOVA_bw)
```


As a follow-up, the most regulated proteins were selected and the fitness of the 
corresponding sgRNAs was plotted as barchart (groups in red from above, 
$p_{value} \leq 0.05$). 



```{r, fig.width = 5, fig.height = 4}
# customize plotting colors a bit
custom.lattice$box.rectangle$col = "#CC476B"#"#00526D"
custom.lattice$box.umbrella$col = "#CC476B"#"#00526D"

# filter dataset for 1 time point only (fitness score is identical
# for all time points of 1 condition)
plot_fitness_ANOVA_pw <- df_ms %>% 
  
  # filter also for most regulated genes = p-value <= 0.01
  filter(timepoint == 0, induction == "i", ANOVA.adj <= 0.05) %>% 
  
  # arrange genes by mean fitness over pathway
  group_by(Process.abbr) %>% 
  mutate(
    mean_fitness = mean(fitness_score, na.rm = TRUE),
    n_sgRNAs = length(unique(sgRNA))) %>%
  arrange(mean_fitness) %>%
  
  # plot fitness per pathway
  xyplot(fitness_score ~ paste0(Process.abbr, " (", n_sgRNAs, ")") %>% factor(., unique(.)) | 
      paste0(condition, " - induced"), .,
    as.table = TRUE, between = list(x = 0.5, y = 0.5),
    par.settings = custom.lattice, lwd = 1.5, layout = c(1,2),
    scales = list(alternating = FALSE, x = list(rot = 30, cex = 0.7)),
    xlab = "cyanobase pathway", ylab = "fitness",
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.violin(x, y, horizontal = FALSE, border = NA, col = grey(0.7, 0.5),... )
      panel.bwplot(x, y, horizontal = FALSE, pch = "|", do.out = FALSE, ... )
    }
  )

print(plot_fitness_ANOVA_pw)
```

```{r, results = 'hide', include = FALSE, eval = FALSE}
svg("../figures/supplemental/Supplemental_figure_prot_regulation_CO2.svg", width = 5, height = 7)
print(plot_fitness_ANOVA_bw, position = c(0, 0.48, 1, 1.04), more = TRUE)
print(plot_fitness_ANOVA_pw, position = c(0, 0, 1, 0.53))
grid.text(label = c("A", "B", "C"), x = c(0.03, 0.03), y = c(0.98, 0.5), gp = gpar(cex = 1.3))
dev.off()
```

----------

**Supplementary Figure. Highly regulated proteins have lower average fitness.**
**A.** Fitness score of sgRNAs broken down by protein variability. Protein variability
was estimated using a proteomics study with measurement of protein abundance over several
light conditions (Jahn et al., Cell Reports, 2018). Here, the adjusted p-value from 
ANOVA over all light conditions was used as a metric for variability. For this comparison,
every sgRNA was mapped to its corresponding protein. Red, proteins with $p_{value} \leq 0.05$).
Blue, proteins with $p_{value} > 0.05$).
**B.** Fitness score of sgRNAs associated with most significantly changing proteins
($p_{value} \leq 0.05$, red in (A), broken down by cyanobase pathways.
In brackets, number of unique sgRNAs per pathway.

----------

## Determine mutant growth rate from depletion over time

The main dataset contains measurements of thousands of sgRNA mutants over time.
The proportion of these mutant sub-populations of the total population 
changes over time depending on their individual growth rate. If a mutant grows faster
than the population average, it will outcompete the other mutants in terms of growth
and enrich in the population. Likewise, mutants with a growth defect be diluted over time
eventually get depleted from the population. Theoretically, this problem is similar
to the mathematical concept of half-life as it is known from nuclear decay. At a certain
rate (half-life), an unstable isotope will break apart into a more stable one releasing 
radiation.

#### Mathematical concept

All parameters to determine the growth rate of each individual mutant are known.
The main parameters are the average growth rate ($\mu$, equals dilution rate ($D$) 
of the population, and the relative fraction of each mutant ($FC$) of the total population 
at the initial and later time points ($t_0, t_i$). 
If a mutant will not grow at all, it is depleted from the library
at the rate of population growth ($D_{total}$). If it grows at a slower rate $D_{mutant}$,
it is depleted from the library at rate $D_{diff}$.

$$ D_{diff} = D_{total} - D_{mutant} $$

The depletion of a mutant from the library can be modeled for arbitrary time points,
where the mutant fraction $F_t$ at time point $t$ becomes

$$ F(t) = F(_{t=0}) \times (1-({D_{total}-D_{mutant}}))^{t} $$
For example, population fraction $F$ after 10 h growth with a population growth rate 
of $D_{total} = 0.1$, a mutant growth rate of $D_{mutant} = 0.05$, and inital population 
fraction of $F(t=0) = 0.1$ is $F(10 h) = 0.1 \times (1-(0.1-0.05))^{10} = 0.059$.
This is effectively a growth model that can be fitted to each sgRNA using the known 
parameters $F(t=0)$, $D_{total}$, and $F(t)$, and solving for $D_{mutant}$. 
To make things easier, it is possibe to use the fold change (FC) as normalized 
measure of read fraction. Then initial population fraction becomes 1 ($F(t=0) = 1$) 
and can be removed from the equation. To fit this model to sgRNA depletion, 
R's standard non-linear fitting system `nls()` can be used.

#### Implementation

```{r}
# prepare reduced data frame
# time in days has has to be converted to time in hours (to match growth rate per hour)
df_mu <- df %>% ungroup %>% 
  mutate(timepoint = timepoint * 24) %>%
  select(condition, timepoint, induction, sgRNA, sgRNA_short, locus, 
    FC, average_growth_rate, Process.abbr)
  

# use a wrapper function for nls() that we can apply on whole data frame
fit_mu <- function(time, pop_mu, FC) {
  # wrap function in a tryCatch statement to handle max iteration errors
  model <- tryCatch(error = function(e) {NULL},
    nls(
      formula = FC ~ (1 - (pop_mu - mut_mu))^time,
      data = data.frame(time = time, pop_mu = pop_mu, FC = FC),
      start = list(mut_mu = 0.01)
    )
  )
  # test for errors and return result
  if (is.null(model)) {
    return(NA)
  } else {
    summary(model)[["parameters"]][[1]]
  }
}


# add modeled depletion to data frame using fitted mutant growth rate
df_mu <- df_mu %>% group_by(condition, induction, sgRNA) %>%
  mutate(
    mutant_growth_rate = fit_mu(timepoint, average_growth_rate, FC),
    FC_fit = (1 - (average_growth_rate - mutant_growth_rate))^timepoint
  )
  
# preview
select(df_mu, -condition, -induction, Process.abbr) %>% head

# save the data
write_csv(df_mu, "../processed_data/CRISPRi_library_df_growthrates.csv")
```


```{r, include = FALSE, eval = FALSE}
# can also load previously computed result table
df_mu <- read_csv("../processed_data/CRISPRi_library_df_growthrates.csv")
```

----------

The result from the growth models is the estimated parameter, the mutant growth rate,
and the predicted depletion/enrichment over time in FC (`FC_fit`). 
However, a first necessary check is to see how many genes failed to get a growth model fitted. 
Second, the distribution of mutant growth rates can be plotted.


```{r}
# check how many models failed (mostly due to NA/missing values)
df_mu %>% group_by(condition, induction) %>% filter(timepoint == 0) %>%
  summarise(
    successful_models = sum(!is.na(mutant_growth_rate)),
    failed_models = sum(is.na(mutant_growth_rate))
  )
```


```{r, fig.width = 4, fig.height = 3}
# customize plotting colors a bit
custom.lattice <- custom.lattice()
custom.lattice$box.rectangle$col = "#00526D"
custom.lattice$box.umbrella$col = "#00526D"
custom.lattice$box.rectangle$lwd = 1.5
custom.lattice$box.umbrella$lwd = 1.5

# plot mutant growth rates
xyplot(mutant_growth_rate ~ paste0(condition, "\n", induction) %>% factor,
  df_mu %>% ungroup %>%
    filter(timepoint == 0, condition != "LD"), groups = induction,
  as.table = TRUE, between = list(x = 0.5, y = 0.5),
  par.settings = custom.lattice, lwd = 1.5,
  xlab = "condition", ylab = "µ_mutant [h-1]", 
  ylim = c(0, 0.1),
  scales = list(alternating = FALSE),
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.violin(x, y, horizontal = FALSE, border = NA, col = grey(0.7, 0.5),... )
    panel.bwplot(x, y, horizontal = FALSE, pch = "|", do.out = FALSE, ... )
  }
)
```

----------

#### Growth rate of sgRNA mutants for selected pathways

We can plot the _predicted_ depletion/enrichment over time _versus_ the _actual_ 
depletion/enrichment. Different sets of interesting genes or pathways could be
selected. For a start, a selection of genes for **photorespiration** and for
**Calvin cycle** related genes can be created. The next step is to compare the 
fitted growth rates for individual mutants, for example between induced and non-induced
conditions.

#### Faster growing sgRNA mutants

A few clones actually gained a condition-dependent fitness advantage over the 
population average. In the case of the turbidostat, cells are selected for maximum
specific growth rate and maximizing fitness is therefore reduced to maximizing
steady-state growth rate for a particular condition. In the next paragraph, 
not only mutants for specific pathways but also faster-growing mutants are 'isolated'.

```{r}
# Photorespiration genes (extracted from Hagemann papers)
list_photores <- c(
  "sll0404", "slr0806", "sll0171", "slr0229", "slr1348", 
  "sll1349", "sll1981", "slr2088", "sll1559", "slr1931"
)

# Calvin cycle genes
list_calvin <- c(
  "sll1525", "slr0012", "slr0009", "slr0394", "sll1342",
  "slr0884", "slr0943", "sll0018", "slr0952", "slr2094",
  "sll1070", "slr0194", "ssl2153", "slr0783", "sll0807",
  "slr1793", "sll0587", "sll1275", "slr0752", "slr1945",
  "slr0084", "slr1349", "slr1124", "sll0395", "slr1748"
)

# faster growing mutants
list_faster <- c(
  "sll1968", "sll1969", "slr1916", "slr1340", "ssl2982",
  "slr1547"
)
```


```{r, fig.width = 9, fig.height = 4}
# plot fitted model and actual depletion together for subset of sgRNAs
plot_mutant_mu <- lapply(c("i", "u"), function(ind) {
  xyplot(log2(FC) + log2(FC_fit) ~ timepoint | sgRNA, 
    df_mu %>% ungroup %>% filter(locus %in% list_faster, condition == "L300", induction == ind),
    as.table = TRUE, between = list(x = 0.3, y = 0.3), layout = c(4, 3),
    par.settings = custom.lattice, type = "l", lwd = 1.5,
    main = paste0("Predicted and actual depletion/ \nenrichment of sgRNAs (L300, ", 
      ifelse(ind == "i", "induced", "uninduced"), ")"),
    xlab = "time [h]", ylab = "log2 FC", ylim = c(-10, 10),
    scales = list(alternating = FALSE),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
      panel.key(c("FC data", "FC model"), corner = c(0.1,0.1), 
        points = FALSE, lines = TRUE, cex = 0.6)
    }
  )
})

print(plot_mutant_mu[[1]], position = c(0.5,0,1,1), more = TRUE)
print(plot_mutant_mu[[2]], position = c(0,0,0.5,1))
```

Comparison of growth rate for the selected genes. Mutant growth rate is
aggregated as mean and standard deviation of the two sgRNAs. Induced _versus_ uninduced
condition is plotted. More informative than plotting actual growth rates is plotting
the % of change in growth rate compared to the population average. The table with mutant
growth rate of all selected strains is saved as a *Supplementary Data* table.

```{r, fig.width = 6, fig.height = 9}
plot_mutant_mu_2 <- lapply(list(list_calvin, list_photores, list_faster), function(genes) {
  
  # adjust scale to selected gene set
  if ("slr1916" %in% genes) ylim = c(90, 130) else ylim = c(-50, 150)
  
  df_mu %>% ungroup %>%
  
  # select subset of sgRNA
  filter(locus %in% genes, condition %in% c("L100", "L300")) %>%
  
  # plot relative change in mutant growth rate compared to pop average
  xyplot(mutant_growth_rate/average_growth_rate*100 ~ factor(sgRNA_short) | condition, .,
    groups = induction, 
    as.table = TRUE, between = list(x = 0.3, y = 0.3), 
    par.settings = custom.lattice, layout = c(1, 2),
    pch = 19, col = c("#00526D", "#CC476B"),
    main = "Mutant growth rate obtained from depletion/enrichment model",
    xlab = "", ylab = "µ [% pop. average]", 
    ylim = ylim, 
    scales = list(alternating = FALSE, x = list(rot = 30, cex = 0.7)),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.abline(h = 100, col = grey(0.5), lty = 2)
      panel.superpose(x, y, ...)
      #panel.key(c("induced", "uninduced"), pch = 19)
    }, panel.groups = function(x, y, ...) {
      panel.errbars(x, y, ewidth = 0, ...)
    }
  )
  
})

print(plot_mutant_mu_2[[1]], position = c(0,0.65,1,1), more = TRUE)
print(plot_mutant_mu_2[[2]], position = c(0,0.32,1,0.67), more = TRUE)
print(plot_mutant_mu_2[[3]], position = c(0,0,1,0.34))
```

```{r, results = 'hide', include = FALSE}
svg("../figures/supplemental/Supplemental_figure_mutant_growth.svg", width = 6, height = 9)
print(plot_mutant_mu_2[[1]], position = c(0,0.65,1,1), more = TRUE)
print(plot_mutant_mu_2[[2]], position = c(0,0.32,1,0.67), more = TRUE)
print(plot_mutant_mu_2[[3]], position = c(0,0,1,0.34))
dev.off()
```

----------

#### Saving processed data frames as Supplemental Data

1. Complete original data frame (including ncRNAs) with extra columns for
   mutant growth rate relative growth rate change in %. 
   This is **Supplemental Data S1**.

```{r, message = FALSE}
# merge master data frame with predicted growth rates
df_all <- df_mu %>% ungroup %>% 
  
  # summarize mutant growth rate as mean and stdev
  group_by(sgRNA_short, condition, induction) %>%
  summarize(
    locus = locus[1],
    population_growth_rate = average_growth_rate[1],
    mean_mutant_growth_rate = mean(mutant_growth_rate),
    stdev_mutant_growth_rate = sd(mutant_growth_rate)
  ) %>%
  
  # add relative change
  mutate(mutant_growth_rate_percent = 
    mean_mutant_growth_rate/population_growth_rate*100) %>%
  
  # select only growth rate-related columns and merge
  select(sgRNA_short, condition, induction, 
    mean_mutant_growth_rate, mutant_growth_rate_percent) %>%
  left_join(df_all, .) %>%
  
  # remove unnecessary columns
  select(-FC, -Gene.ontology.IDs, -Process.abbr, -Pathway.abbr)

# and save to disk
write_csv(df_all, "../processed_data/Supplemental_data_S2.csv")
```


2. Selected genes for photorespiation, Calvin cycle, and increased growth rate.
   This is **Supplemental Data S4**.

```{r}
df_all %>% ungroup %>% 
  
  # select subset of sgRNAs and conditions
  filter(
    locus %in% c(list_calvin, list_photores, list_faster), 
    condition %in% c("L100", "L300"),
    timepoint == 0,
    sgRNA_index == 1
  ) %>%
  
  # select only important columns
  select(sgRNA_short, condition, induction, locus, 
    average_growth_rate, mean_mutant_growth_rate, 
    mutant_growth_rate_percent) %T>% print %>% 
  
  write_csv("../processed_data/Supplemental_data_S4.csv")
```


