---
title: "CRISPRi library enrichment/depletion analysis"
output:
  html_notebook:
    toc: yes
---


## Description

The purpose of this R markdown notebook is to provide a trackable, reproducible,
and comprehensive documentation of data processing steps for experiments carried 
out using a CRISPRi sgRNA library in the  cyanobacterium _Synechocystis_ sp. PCC6803.

This is the second pipeline of two, focusing on analysis of enrichment or depletion of 
CRISPRi-repressed mutants in growth competiion experiments. The experimental 
details will be published in a corresponding paper. This pipeline uses different
strategies of clustering sgRNAs by similarity, checking for enriched gene ontology 
terms, and picking out the most interesting sgRNAs/genes per cluster.


```{r, results = 'hide', message = FALSE}
# LOAD PACKAGES

library(lattice)
library(latticeExtra)
library(cluster)
library(dendextend)
library(topGO)
library(tidyverse)
library(Rtools)
library(grid)
```


## Step 1: Loading preprocessed data

Preprocessed data in the form of reads per gene was summarized and annotated 
in pipeline 1. It includes mean read fraction, log2 FC and p-value calculated 
using DESeq2. Genome annotation was added based on uniprot and cyanobase annotation
of the reference genome for _Synechocystis_ sp. PCC6803.

```{r}
# load data file
load(file = "../processed_data/CRISPRi_library_df_annotated.Rdata")
# turn conditon into a factor for ordered plotting, input should be ungroup()ed
df <- ungroup(df) %>% mutate(condition = factor(condition, c("L100", "L300", "LD", "LAC", "NACL")))
# split into gene and ncRNA containing data and continue with gene only
df_ncRNA <- df %>% filter(grepl("^Entry", sgRNA))
df <- df %>% filter(!grepl("^Entry", sgRNA))
```


## Step 2: Basic statistics

The purpose of this section is to investiagte basic statistical properties
of the annotated sgRNA library data. This includes 'coverage' metrics like total 
number of unique sgRNAs, unique genes, missing values per condition, and 
distribution of raw read fractions or log2 FCs.

```{r}
# Number of unique sgRNAs
paste(df$sgRNA %>% unique %>% length, "unique sgRNAs in all conditions")
# Number of unique genes
paste(df$locus %>% unique %>% length, "unique genes covered")
# Missing sgRNA quantifications per condition, higher for LAC
df %>% group_by(condition, induction, sgRNA) %>%
  summarise(NAs = sum(is.na(read.fraction.mean))) %>% 
  summarise(sum(NAs > 0))
```

-----------

#### Read distribution

The distribution of raw read fraction should ideally be a normal or Gauss-distribution,
meaning that most of the mutants in the sgRNA library are equally distributed. 
However, there is clearly a skewed and in several cases a bimodal distribution visible,
indicating that a sub-population of mutants was already depleted from the library
(or always present at lower proportion) at the 0 d time point.

```{r}
# Raw read fraction distribution
plot_read_density <- densityplot( ~ log10(read.fraction.mean) | 
    plyr::mapvalues(induction, c("i", "u"), c("induced", "uninduced")) * condition, 
  groups = timepoint, df, 
  col = colorRampPalette(custom.lattice()$superpose.line$col[1:3])(7),
  as.table = TRUE, scales = list(alternating = FALSE),
  xlab = bquote(log[10] ~ "read fraction"),
  par.settings = custom.lattice, between = list(x = 0.5, y = 0.5),
  xlim = c(-7.5,-0.5),
  panel = function(x, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.densityplot(x, plot.points = FALSE, lwd = 2, ...)
    panel.key(labels = c("0d","1d","2d","4d","8d","16d","32d"), 
      points = FALSE, lines = TRUE, lwd = 2, which.panel = 10,
      col = colorRampPalette(custom.lattice()$superpose.line$col[1:3])(7))
  }
)
```

```{r, fig.align = 'center', fig.width = 6.5, fig.height = 8}
print(plot_read_density)
```


```{r, results = 'hide', include = FALSE}
svg("../figures/supplemental/Supplemental_figure_read_density.svg", width = 6.5, height = 8)
print(plot_read_density)
dev.off()
```

-----------

**Supplemental Figure. NGS read distribution per sample.**
Distribution of mean read fraction (sgRNA reads per gene divided by total number 
of reads). Broken down by condition, and color-coded by time point in days. A bimodal
disitrubtion for some conditions indicate that a pre-selection of mutants was 
taking place eve before growth competition experiments.
Abbreviations: L100 - light with 100 µmol photons m<sup>-2</sup> s<sup>-1</sup>, L300 - light with 300 µmol photons m<sup>-2</sup> s<sup>-1</sup>, LD - light-dark-cycle, LAC - addition of lactate, NACL - addition of sodium chloride.

-----------


#### sgRNA pair correlation

To get a more detailed picture how well 2 sgRNAs for the same gene compare, 
the log2 FC of sgRNA 1 is plotted against sgRNA 2. The ideal is a perfect correlation
between every sgRNA pair but this is unlikely to happen. Here, sgRNA correlation
is broken down by condition.

```{r, fig.width = 9, fig.height = 9}
# Correlation between sgRNA 1 and 2 per gene, and condition
plot_2sgRNA_correlation <- xyplot(`sgRNA-2` ~ `sgRNA-1` | 
  factor(timepoint) * condition,
  # filter out genes that don't have two sgRNAs
  df[c(2,3,4,9,14,15,16)] %>% group_by(sgRNA_short) %>%
    filter(timepoint > 0) %>%
    spread(key = sgRNA_index, value = log2FoldChange) %>%
    rename_at(vars(6:7), function(x) paste0("sgRNA-", x)),
  groups = induction, as.table = TRUE, 
  between = list(x = 0.5, y = 0.5),
  par.settings = custom.lattice, cex = 0.2, pch=19,
  scales = list(alternating = FALSE),
  xlim = c(-9, 4), ylim = c(-9, 4),
  xlab = bquote(log[2] ~ "FC sgRNA1"), ylab = bquote(log[2] ~ "FC sgRNA2"),
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.xyplot(x, y, ... )
    if (panel.number() %in% c(1:5, 7:11, 17:18, 23:24, 29:30)) {
      panel.quadrants(x, y, h = -2, v = -2, lwd = 2, col = grey(0.3), ...)
    }
    panel.key(which.panel = 6, c("induced", "uninduced"), pch = 19, corner = c(0.1, 0.9))
  }
)

print(plot_2sgRNA_correlation)
```


```{r, results = 'hide', include = FALSE}
png("../figures/supplemental/Supplemental_figure_2sgRNA_correlation.png", 
  width = 1200, height = 1200, res = 120)
print(plot_2sgRNA_correlation)
dev.off()
```

-----------

**Supplemental Figure. Correlation of sgRNA pairs for each gene.**
Correlation of the log2 FC of sgRNA1 _versus_ sgRNA 2 for each gene,
broken down by condition. Each panel shows an overlay of induced (blue) and uninduced (red)
samples. Panel numbers indicate time in days.
Abbreviations: L100 - light with 100 µmol photons m<sup>-2</sup> s<sup>-1</sup>, 
L300 - light with 100 µmol photons m<sup>-2</sup> s<sup>-1</sup>, LD - light-dark cycle, LAC - addition of lactate, NACL - addition of sodium chloride.

-----------

#### sgRNA pair correlation, subset of ribosomal proteins

Using the same strategy as above, we can also plot only ribosomal genes in order
to see if correlation for both sgRNAs for these highly essential genes is higher.
Here only constant light conditions 100 and 300 µmol photons m<sup>-2</sup> s<sup>-1</sup> 
were selected.

```{r, fig.width = 7.5, fig.height = 4, echo = FALSE}
# Correlation between sgRNA 1 and 2 per gene, and condition
plot_2sgRNA_correlation_rib <- df %>% 
  
  # filter out genes that don't have two sgRNAs
  filter(Pathway.abbr == "Ribosomal proteins", condition %in% c("L100", "L300")) %>% 
  select(c(2,3,4,9,14,15,16)) %>%
  group_by(sgRNA_short) %>%
  filter(timepoint > 0) %>%
  spread(key = sgRNA_index, value = log2FoldChange) %>%
  rename_at(vars(6:7), function(x) paste0("sgRNA-", x)) %>%
  
  # plot
  xyplot(`sgRNA-2` ~ `sgRNA-1` | factor(timepoint) * condition, .,
    groups = induction, as.table = TRUE, 
    between = list(x = 0.5, y = 0.5),
    par.settings = custom.lattice, cex = 0.2, pch=19,
    scales = list(alternating = FALSE),
    xlim = c(-9, 4), ylim = c(-9, 4),
    xlab = bquote(log[2] ~ "FC sgRNA1"), 
    ylab = bquote(log[2] ~ "FC sgRNA2"),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ... )
      panel.quadrants(x, y, h = -2, v = -2, lwd = 2, col = grey(0.3), ...)
      panel.key(which.panel = 6, c("induced", "uninduced"), pch = 19, corner = c(0.1, 0.9))
    }
  )

print(plot_2sgRNA_correlation_rib)
```


```{r, results = 'hide', include = FALSE}
png("../figures/supplemental/Supplemental_figure_2sgRNA_correlation_rib.png", 
  width = 1000, height = 530, res = 120)
print(plot_2sgRNA_correlation_rib)
dev.off()
```


----------

## Step 3: Unsupervised clustering of sgRNAs

A matrix is generated from sgRNA log2 FC values to apply clustering and plot
a heatmap. The matrix should be in 'wide' format while the master data frame
is  in 'long' format (one variable/observations per column). 


```{r, results = 'hide'}
mat <- unite(df, condition, condition, induction, timepoint) %>%
  
  # combine sgRNA indices (will be rows) to help spreading
  unite(sgRNA, sgRNA_short, sgRNA_index) %>%
  
  # select only the required columns
  select(sgRNA, condition, log2FoldChange) %>%
  
  # replace NA in log2FoldChange with 1
  mutate(log2FoldChange = coalesce(log2FoldChange, 0)) %>%
  
  # and spread with condition as key and log2foldchange as value
  spread(key = condition, value = log2FoldChange) %>%
  
  # rename columns clumsily
  rename_at(vars(ends_with("_0")), funs(sub("_0$", "_00", .))) %>%
  rename_at(vars(ends_with("_1")), funs(sub("_1$", "_01", .))) %>%
  rename_at(vars(ends_with("_2")), funs(sub("_2$", "_02", .))) %>%
  rename_at(vars(ends_with("_4")), funs(sub("_4$", "_04", .))) %>%
  rename_at(vars(ends_with("_8")), funs(sub("_8$", "_08", .))) %>%
  
  # change row names
  column_to_rownames("sgRNA") %>% ungroup %>%

  # reorder columns and exclude LAC/NACL data
  select(sort(colnames(.))) %>% 
  select(contains("L100"), contains("L300"), contains("LD")) %>%
  select(contains("_u_"), contains("_i_")) %>% as.matrix
```

----------

The data matrix is primarily used for clustering. For this purpose, a dissimilarity 
matrix is computed using R's `dist()` function with distance measure 
`euclidean`. The clustering is performed using function `hclust()` 
with method `ward.D2`.

```{r}
# for more info on clustering algorithm, see hclust manual
cluster <- hclust(dist(mat), method = "ward.D2")
```

----------

#### Choose and plot selected clusters

To evaluate the quality of clustering (maximum within-cluster similarity 
over minimum between-cluster similarity), silhouette analysis is performed. 
Silhouette analysis can be iteratively applied for a range of cluster numbers,
prerequisite is only a cluster object such as obtained from `hclust()`.

```{r}
silhouetteResult <- Rtools::silhouetteAnalysis(mat, cluster, 2:20)

print(silhouetteResult$plot.clusters, position = c(0, 0, 0.6, 1), more = TRUE)
print(silhouetteResult$plot.summary, position = c(0.6, 0, 1, 1))
```


```{r, results = 'hide', include = FALSE}
svg("../figures/supplemental/Supplemental_figure_average_silhouette.svg", 9, 5)
print(silhouetteResult$plot.clusters, position = c(0, 0, 0.6, 1), more = TRUE)
print(silhouetteResult$plot.summary, position = c(0.6, 0, 1, 1))
dev.off()
```

----------

The result from silhouette analysis of 2 to 20 clusters indicates that a cluster 
number of 2 to 9 offers good separation, while higher cluster numbers reduce
silhouette width. Next, a certain number of clusters was chosen and the 
dendrogram was split at a height that will produce the corresponding number
of clusters. Here, `cutreeord()` from R package `vegan` was used to cut 
the dendrogram. The resulting clusters were re-ordered and two similar unchanged 
clusters merged into one.


```{r, message = FALSE}
# We can select the k upmost clusters using cutree. 
clusters <- vegan::cutreeord(cluster, k = 6); clusters %>% table

# combine clusters 5 and 6 as they are very similar
clusters <- clusters %>% recode(`2` = 1L, `1` = 2L, `3` = 4L, `4` = 3L, `6` = 5L) %>% 
  setNames(., names(clusters))

# The cluster order by cutree does not correspond to the one of the dendrogram
# therefore change order of clusters manually using factor levels
clusters <- factor(clusters, unique(clusters) %>% sort)

# make the silhouette for plotting
sil <- silhouette(as.numeric(clusters), dist(mat))

# merge predicted clusters with df
df <- group_by(df, condition, timepoint, induction) %>% mutate(cluster = clusters)

# re-order the dendrogram a bit for plotting, in order of clusters
cluster_reordered <- as.dendrogram(cluster) %>% 
  reorder(wts = clusters[cluster$labels], agglo.FUN = mean)
```


```{r, include = FALSE}
# custom color vector for clusters, without first color that equals last
custom_palette <- colorspace::qualitative_hcl(
  n = length(unique(clusters)), h = c(30, 360), c = 100, l = 50)
custom_lattice <- custom.lattice()
custom_lattice$superpose.polygon$col = custom_palette
custom_lattice$superpose.symbol$col = custom_palette
custom_lattice$superpose.line$col = custom_palette
```

----------

#### Plotting heatmap and dendrogram

Heat map and colored dendrogram are plotted and then externally combined into
one figure because they use different graphic systems (`grid` graphics 
_versus_ `base` graphics).

```{r, fig.width = 18, fig.height = 6.5}
# plot colored dendrogram
plot(color_branches(cluster_reordered,
  groupLabels = as.numeric(levels(clusters)), lwd = 1,
  col = custom_palette[as.numeric(levels(clusters))],
  clusters = sort(as.numeric(clusters))
))
```


```{r, fig.width = 18, fig.height = 4}
# plot heatmap according to clustered protein groups
plot_heatmap <- levelplot(
  # limit plotted range to log2 FC of -5 to 5 (32 fold)
  mat[as.hclust(cluster_reordered)$order, ] %>% replace(., . > 5, 5) %>% replace(., . < -5, -5),
  col.regions = colorRampPalette(c(custom_palette[4], grey(0.95), custom_palette[1])),
  as.table = TRUE, aspect = "fill", 
  xlab = "sgRNA", ylab = "time [d]",
  scales = list(alternating = FALSE, x = list(draw = FALSE))
)

print(plot_heatmap)
```


```{r, results = 'hide', include = FALSE}
# export both dendrogram and heatmap
  png("../figures/main/CRISPRi_library_dendrogram.png", , width = 1800, height = 650, res = 165)
plot(color_branches(cluster_reordered,
  groupLabels = as.numeric(levels(clusters)), lwd = 1,
  col = custom_palette[as.numeric(levels(clusters))],
  clusters = sort(as.numeric(clusters))
))
dev.off()

png("../figures/main/CRISPRi_library_heatmap.png", width = 1800, height = 300, res = 165)
print(plot_heatmap)
dev.off()

```


----------

#### sgRNA depletion in major clusters

Heatmap and dendrogram show that a large part of sgRNAs is not depleted, either 
because they target non-essential genes under the given condition, or the 
repression efficiency is low for various reasons. The next part takes a closer
look at sgRNA depletion over time broken down by cluster.

```{r}
# this plot is printed on one page together with the following GO term analysis
plot_library_depletion <- xyplot(log2FoldChange ~ generations | paste(condition, " - ", cluster),
  # we have to add one more fake data point, at max of 50 generations, with NA
  # so that lines are broken after last time point
  bind_rows(
    df %>% ungroup %>% filter(induction == "i", condition %in% c("LD", "L300", "L100")),
    df %>% ungroup %>% filter(induction == "i", condition %in% c("LD", "L300", "L100"), timepoint == 0) %>%
      mutate(generations = 50, log2FoldChange = NA)
  ) %>% arrange(condition, cluster, sgRNA, generations),
  groups = cluster, type = "l", between = list(x = 0.5, y = 0.5), 
  as.table = TRUE, layout = c(length(unique(clusters)), 3),
  col = paste0(custom_lattice$superpose.polygon$col, "20"),
  xlab = "generations", ylab = bquote(log[2] ~ "FC"), 
  ylim = c(-8, 4), xlim = c(0, 40),
  scales = list(alternating = FALSE), pch = 16, cex = 0.7, 
  par.settings = custom_lattice,
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.xyplot(x, y, ...)
    #panel.stripplot(x, y, jitter.data = TRUE, amount = 0.2, horizontal = FALSE, ...)
    medianFC <- tapply(y, x, function(x) median(x, na.rm=TRUE))
    panel.xyplot(names(medianFC) %>% as.numeric, medianFC, col = grey(0.3), type = "l", lwd = 3)
    panel.text(20, 2.5, paste(length(x)/length(unique(x)), "sgRNAs"), cex = 0.8, col = grey(0.3))
  }
)
```

----------

## Step 4: Gene ontology (GO) term enrichment

For GO term enrichment, the `TopGO` package by Alexa et al., 2006, was used to
determine GO terms associated with sgRNAs for the first four clusters. The function
uses the hypergeometric test internally to test enrichment of one group against the 
'background' of all genes/sgRNAs. Reference:

_Alexa A., Rahnenfuhrer J., Lengauer T., Improved scoring of functional groups from gene expression data by decorrelating GO graph structure, Bioinformatics 22(13): 1600-1607, 2006._


```{r, results = 'hide', message = FALSE}
library(topGO)

# the GetTopGO function takes as input either
#   1. a data frame with one row per gene as only presence in cluster is 
#      important here. Three columns are obligatory, "cluster", "GeneID", and 
#      "Gene.ontology.IDs" with GO terms separated by '; '
#   2. alternatively three vectors or lists corresponding to
#      the three columns can be provided

TopGoResult <- lapply(1:length(unique(clusters)), function(i) {
    with(df[!duplicated(df$sgRNA), ] %>% as.data.frame,
      GetTopGO(df = NULL,
        cluster = as.numeric(cluster),
        GeneID = sgRNA,
        Gene.ontology.IDs,
        topNodes = 50, 
        selected.cluster = i
      )
    )
  }) %>%

  # regarding p-value adjustment: the authors discourage from multiple 
  # hypothesis testing and indeed, it turns most p-values insignificant
  setNames(1:length(unique(clusters))) %>%
    
  # turn into data frame with cluster as ID columns
  plyr::ldply(., .id = "cluster")
    
  # save unfiltered TopGO result
  write_csv(TopGoResult, "../processed_data/TopGoResult.csv")
```


```{r, include = FALSE, eval = FALSE}
# optionally read precomputed TopGO results file
TopGoResult <- read_csv("../processed_data/TopGoResult.csv")
```

----------

In an effort to filter the resulting extensive list of GO terms,
a filtering step using `REVIGO` was conducted that excludes redundant GO terms.
To this end, the result table was uploaded to http://revigo.irb.hr/ and a table with
redundancy scores obtained. `REVIGO` scores were used to trim the GO terms to
the most essential/unique ones. GO terms with a redundancy score above 0.5 were
filtered out, as well as GO terms annotated with less than 5 or more than 200 
unique sgRNA/genes. The p-value cutoff used for display in Figure 2 C was 0.03. 
The p-value obtained from `TopGO`'s  method `Fisher, eliminating`.

```{r, message = FALSE}
# merge TopGo result with REVIGO dispensibility analysis
TopGoResultFiltered <- left_join(as_tibble(TopGoResult), read_csv("../processed_data/REVIGO.csv"), 
  by = c("GO.ID" = "term_ID")) %>%
  
  # trim data frame by p.value and GO term node size
  filter(dispensability <= 0.5,
    elimFisher < 0.03,
    Annotated >= 5,
    Annotated <= 200) %>%
  
  # optionally trim lengthy GO terms and fuse with cluster (some show up several times)
  mutate(
    TermAbbr = gsub("(biosynthetic|metabolic|catabolic) proce?s?s?|\\.\\.\\.|metabolic.?.?.?", 
    replacement = "", Term) %>% substr(1, 20) %>%
    paste0(., "...", cluster)
  ) %>% filter(!duplicated(TermAbbr))

head(TopGoResultFiltered)
```

----------

#### Figure 2 - combined results of depletion and GO term enrichment

The results of GO term enrichment together with depletion/enrichment of sgRNAs 
per cluster were combined in **Figure 2**. 

```{r}
# plot of enriched GO terms per cluster
plot_TopGO_table <- xyplot(factor(TermAbbr, unique(TermAbbr)) ~ as.numeric(elimFisher), 
  TopGoResultFiltered %>% filter(cluster != 5) %>% arrange(desc(cluster), desc(elimFisher)), 
  groups = factor(cluster), main = "", 
  par.settings = custom_lattice, xlab = "p-value", ylab = "",
  #scales = list(alternating = FALSE, x = list(rot = 45)), 
  panel = function(x, y, groups = groups, subscripts = subscripts, ...) {
    panel.abline(h = 1:length(y), col = grey(0.9), lty = 2)
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.key(labels = paste("cluster", 1:4), pch = 19, corner = c(0.9, 0.95))
    panel.superpose(x, y, groups, subscripts, ...)
  },
  panel.groups = function(x, y, groups = groups, subscripts = subscripts, ...) {
    panel.xyplot(x, y, cex = 2.5-(50*x), pch = 19, alpha = 0.7,
      col = custom_lattice$superpose.polygon$col[subscripts])
  }
)
```


```{r, fig.width = 5, fig.height = 5, warning = FALSE, message = FALSE}
# custom function to plot single sgRNAs per most enriched GO terms
plot.sgRNAs <- function(data, comment = NULL) {
  
  xyplot(log2FoldChange ~ factor(timepoint), 
    data, as.table=TRUE, groups = cluster,
    xlab = "time [d]", ylab = bquote(log[2] ~ "FC"), 
    between = list(x = 0.5, y = 0.5),
    layout = c(5, 4),
    ylim = c(-9, 3), pch = 19, cex = 0.2, lwd = 2, 
    par.settings = custom_lattice,
    scales = list(alternating = FALSE),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.superpose(x, y, ...)
      panel.text(3, 2, labels = comment, cex = 0.6, col = grey(0.5))
    },
    panel.groups = function(x, y, ...) {
      panel.stripplot(x, y, jitter.data = TRUE, amount = 0.2, horizontal = FALSE, ...)
      panel.smoother(x, y, ...)
    }
  )
}

# make plots with genes for the most enriched GO terms
plot.list <- filter(TopGoResultFiltered, cluster != 5) %>%
  
  # select top 4 terms per cluster by p-value
  group_by(cluster) %>% slice(1:4) %>%
  
  # pass only the abbreviated GO term/cluster combination
  pull(TermAbbr) %>% lapply(., function(x) {
  
    # extract sgRNA or gene IDs
    sgRNAs = filter(TopGoResultFiltered, TermAbbr %in% x)$SigGenes %>%
      strsplit(split = ",") %>%
      unlist
  
    # generate plot of subsetted data
    plot.sgRNAs(
      data = filter(df, sgRNA %in% sgRNAs, induction == "i") %>%
        mutate(log2FoldChange = coalesce(log2FoldChange, 0)),
      comment = paste(length(sgRNAs), "sgRNAs")
    )
  }) %>%
  
  setNames(filter(TopGoResultFiltered, cluster != 5) %>% 
    group_by(cluster) %>% slice(1:4) %>% 
    pull(TermAbbr) %>% substr(1, 15))

print(do.call(c, plot.list))
```


```{r, fig.align = 'center', fig.width = 10, fig.height = 9, warning = FALSE}
print(plot_library_depletion, position = c(0, 0, 0.69, 0.6), more = TRUE)
print(plot_TopGO_table, position = c(0.65, 0, 1, 0.6))
grid.text(label = c("a", "b", "c"), x = c(0.03, 0.03, 0.67), 
  y = c(0.98, 0.58, 0.58), gp = gpar(cex = 1.3))
```


```{r, results = 'hide', include = FALSE}
svg("../figures/main/CRISPRi_library_TopGoResult.svg", width = 10, height = 9)
print(plot_library_depletion, position = c(0, 0, 0.69, 0.6), more = TRUE)
print(plot_TopGO_table, position = c(0.65, 0, 1, 0.6))
grid.text(label = c("a", "b", "c"), x = c(0.03, 0.03, 0.67), 
  y = c(0.98, 0.58, 0.58), gp = gpar(cex = 1.3))
dev.off()
```

----------

**Figure 2. Enrichment or depletion of CRISPRi library mutants during photoautotrophic conditions.**
**a** Clustered sgRNAs by similarity of log2 FC over time. Cluster 1 to 4 comprise
sgRNAs with with decreasing degree of depletion. Cluster 5 comrpises sgRNAs that remained
unchanged over the tested conditions.
**b** Log2 fold change of each individual sgRNA over time course of a growth
competition experiment. Experiment run time was normalized to generations based on
the average growth rate of a population in the photobioreactor. SgRNA abundance was
determined by HT sequencing of the sgRNA constructed integrated into the genome.
Each panel shows sgRNAs for one particular condition (L100 - light with 100 
µmol photons m<sup>-2</sup> s<sup>-1</sup>, L300 - light with 100 µmol photons m<sup>-2</sup> s<sup>-1</sup>, LD - light-dark-cycle) and cluster (1-5).
**c** Enriched gene ontology (GO) terms for the four clusters (1-4) showing 
sgRNA depletion. GO term enrichment was performed using the TopGO package in R 
(Materials and Methods). Many signifantly enriched terms are related to essential
metabolic traits such as photosynthesis or translation.


----------

## Step 5: Fitness difference between different light conditions

The fitness score F was used as major determinant to find differences between
selected conditions and clusters. The following section makes a three-step analysis:
First, global fitness score distribution was compared between L100 and L300 per cluster. 
Then the strongest difference between the two conditions for specific sgRNAs was 
investigated, and sgRNAs with the highest differential fitness score dF were selected. 
Finally, the depletion/enrichment over time is shown for 20 selected genes where both
sgRNAs are depleted.


**Subfigure A: Difference in fitness score distribution between L100 and L300**

```{r}
# choose one of: c("L100", "L300"), c("L100", "LD"), c("L300", "LD")
light_conditions <- c("L300", "LD")

plot_global_fitness <- df %>%
    
  # select conditions for comparison
  filter(condition %in% light_conditions, induction == "i",
    timepoint == 0, cluster != 5) %>% 
  
  # create boxplot or violinplot for fitness score, direct comparison
  xyplot(fitness_score ~ factor(condition, light_conditions) | factor(cluster), .,
    as.table = TRUE, par.settings = custom_lattice,
    groups = cluster, between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE), layout = c(4,1),
    xlab = "", ylab = "fitness score F",
    ylim = c(-8, 3), 
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.stripplot(as.numeric(x)-0.25, y, jitter.data = TRUE, amount = 0.14, 
        pch = ".", cex = 2, horizontal = FALSE, ...)
      panel.violin(as.numeric(x)+0.25, y, horizontal = FALSE, box.ratio = 0.5, 
        border = grey(0.5), col = custom_palette[panel.number()], ...)
    }
  )
```

----------

**Subfigure B: Differential fitness score (dF) per gene, cluster and `cyanobase pathway`**

```{r}
# Have a look at strongest difference between sgRNAs 
# of two conditions. First create a list of candidates.
df_selected_fitness <- df %>% ungroup %>%
  
  # select conditions for comparison
  filter(condition %in% light_conditions, induction == "i",
    timepoint == 0, cluster != 5) %>%
  
  # make sure order of conditions is correct
  mutate(condition = factor(condition, light_conditions)) %>%
  
  # optional filter for sgRNAs that have 2 members per cluster
  group_by(cluster, sgRNA_short) %>% filter(length(sgRNA_index) == 4) %>% 
  
  # filter by highest fitness difference between sgRNA of two conditions (L300-L100)
  # positive for stronger L300 depletion, negative for stronger L100 depletion
  group_by(cluster, sgRNA_short) %>% summarise(
    diff_fitness_score = mean(fitness_score[c(2,4)]) - mean(fitness_score[c(1,3)]),
    Process.abbr = unique(Process.abbr)
  ) %>% 
  
  # group by cluster and sort by fitness score for top n filtering
  group_by(cluster) %>% arrange(cluster, desc(diff_fitness_score))


plot_diff_fitness <- xyplot(diff_fitness_score ~ factor(Process.abbr) | factor(cluster), 
  df_selected_fitness, group = between(diff_fitness_score, -3, 3),
  xlab = "", ylab = paste0("dF (",light_conditions[2], "-", light_conditions[1], ")"), #L300-L100
  par.settings = custom_lattice, type = "p", pch = 19, as.table = TRUE, 
  col = c("#D33F6A", "#00989D"),
  scales = list(alternating = FALSE, x = list(rot = 45, cex = 0.65)), 
  ylim = c(-6, 6), between = list(x = 0.5, y = 0.5),
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.abline(h = c(-3, 3), lty = 2, lwd = 1, col = grey(0.5))
    panel.stripplot(x, y, jitter.data = TRUE, amount = 0.2, 
      alpha = 0.6, horizontal = FALSE, ...)
    panel.text(1, 4, pos = 4, col = grey(0.5),
      labels = paste0(sum(y <= -3 | y >= 3, na.rm = TRUE), " out of ", length(y), " genes"))
  }
)
```

----------

**Subfigure C: Log2FC over number of generations for the most different sgRNAs**

```{r}
df_selected_genes <- filter(df_selected_fitness, 
  !between(diff_fitness_score, -3, 3)#, 
  #!grepl("^s[sl][lr][0-9]{4}", sgRNA_short)
  ) %>% 
  pull(sgRNA_short)
  
plot_top_diff_fitness <- xyplot(log2FoldChange ~ generations | 
      paste0(cluster, "   ", sgRNA_short), 
    df %>% filter(sgRNA_short %in% df_selected_genes[1:18], 
      induction == "i", condition %in% light_conditions),
    as.table = TRUE, groups = paste(condition, sgRNA_index) %>% factor(., unique(.)[c(2,4,1,3)]), 
    par.settings = {cust = custom_lattice;
      cust$superpose.polygon$col = c("#00989D", "#00989D", "#D33F6A", "#D33F6A"); cust}, 
    type = "l", layout = c(6, 3), 
    scales = list(alternating = FALSE, cex = 0.8),
    ylim = c(-10, 10), xlim = c(0, 17), ylab = bquote(log[2] ~ "FC"),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.key(light_conditions, points = FALSE, col = c("#D33F6A", "#00989D"),
        lines = TRUE, cex = 0.7, corner = c(0.05, 0.95), ...)
      panel.abline(h = 0, lty = 2, lwd = 1.5, col = grey(0.5))
      panel.xyarea(x, y, origin = 0, alpha = 0.6, ...)
    }
  )
```


```{r, fig.width = 5, fig.height = 8, warning = FALSE}
print(plot_global_fitness, position = c(0, 0.72, 1, 1), more = TRUE)
print(plot_diff_fitness, position = c(0, 0.39, 1, 0.78), more = TRUE)
print(plot_top_diff_fitness, position = c(-0.02, 0, 1, 0.46))
grid.text(label = c("a", "b", "c"), x = c(0.03, 0.03, 0.03), 
  y = c(0.98, 0.74, 0.42), gp = gpar(cex = 1.3))
```

  
```{r, results = 'hide', include = FALSE}
svg("../figures/main/Figure3.svg", width = 5, height = 8)
print(plot_global_fitness, position = c(0, 0.72, 1, 1), more = TRUE)
print(plot_diff_fitness, position = c(0, 0.39, 1, 0.78), more = TRUE)
print(plot_top_diff_fitness, position = c(-0.02, 0, 1, 0.46))
grid.text(label = c("a", "b", "c"), x = c(0.03, 0.03, 0.03), 
  y = c(0.98, 0.74, 0.42), gp = gpar(cex = 1.3))
dev.off()
```


```{r, results = 'hide', include = FALSE}
# Supplemental Dataset S4: table with most different sgRNAs as *.csv
filter(df, 
  sgRNA_short %in% (filter(df_selected_fitness, 
    !between(diff_fitness_score, -3, 3)) %>% 
    pull(sgRNA_short) %>% c(., "ndhD3", "sll0871", "slr0379", "slr1302")),
  timepoint == 0, induction == "i", condition %in% c("L100", "L300", "LD")
  ) %>% ungroup %>%
  
  select(locus, sgRNA, sgRNA_short, condition, Process, 
    Pathway, fitness_score, cluster) %>%
  
  write_csv("../processed_data/Supplemental_data_S4.csv")
```


----------

**Figure 3. Genes with condition dependent fitness for high and low light.**
**a** Distribution of fitness score F for all sgRNAs in cluster 1 to 4. Fitness score
indicates the degree of enrichment (positive) or depletion (negative) of an sgRNA.
Comparison between low light (L100 - light with 100 µmol photons m<sup>-2</sup> s<sup>-1</sup>) and high light intensity (L300 - light with 300 µmol photons m<sup>-2</sup> s<sup>-1</sup>) shows sgRNAs are on average stronger depleted under high light.
**b** Difference between fitness score of high light and low light (dF) for 
genes with both sgRNAs in the same cluster. Cluster 3 contains most differentially
depleted/enriched sgRNAs of all clusters (red symbols, threshold: 3 <= dF <= -3).
**c** Selection of top 18 genes with dF above threshold as described in B.
Only genes with 2 depleted/enriched sgRNAs and annotated description were selected.

----------

#### Fitness between light-dark (LD) cycle and high/low light (L300/L100)

The same procedure was applied for a comparison between high/low light (L300/L100) and 
light-dark cycle (LD). The differences were negligible between LD and L300 conditions.
This indicates that a LD cycle with a specific maximum light intensity at noon
selects for a very similar set of genes as constant light at the same
light intensity. In other words, fitness per gene is similar between the LD and 
L300. The method applied for this comparison was exactly as for the L100-L300
comparison, therefore only the result is presented as a **Supplemental Figure**.


```{r, fig.width = 5, fig.height = 8}
print(plot_global_fitness, position = c(0, 0.72, 1, 1), more = TRUE)
print(plot_diff_fitness, position = c(0, 0.39, 1, 0.78), more = TRUE)
print(plot_top_diff_fitness, position = c(-0.02, 0, 1, 0.46))
grid.text(label = c("a", "b", "c"), x = c(0.03, 0.03, 0.03), 
  y = c(0.98, 0.74, 0.42), gp = gpar(cex = 1.3))
```


```{r, results = 'hide', include = FALSE}
svg("../figures/supplemental/Supplemental_figure_fitness_L100_LD.svg", width = 5, height = 8)
print(plot_global_fitness, position = c(0, 0.72, 1, 1), more = TRUE)
print(plot_diff_fitness, position = c(0, 0.39, 1, 0.78), more = TRUE)
print(plot_top_diff_fitness, position = c(-0.02, 0, 1, 0.46))
grid.text(label = c("a", "b", "c"), x = c(0.03, 0.03, 0.03), 
  y = c(0.98, 0.74, 0.42), gp = gpar(cex = 1.3))
dev.off()
```

----------

**Supplemental Figure. Genes with condition dependent fitness for high light and light-dark cycle.**
**a** Distribution of fitness score F for all sgRNAs in cluster 1 to 4. Fitness score
indicates the degree of enrichment (positive) or depletion (negative) of an sgRNA.
Comarison between light-dark cycle (LD - light between 0 and 300 µmol photons m<sup>-2</sup> s<sup>-1</sup>) and high light intensity (L300 - light with 300 µmol photons m<sup>-2</sup> s<sup>-1</sup>) shows similar depletion of sgRNAs.
**b** Difference between fitness score of high light and light-dark cycle (dF) for 
genes with both sgRNAs in the same cluster (red symbols, threshold: 3 <= dF <= -3).
**c** Four genes have a dF above threshold as described in B. Only genes with 2 
depleted/enriched sgRNAs were selected.

----------

#### Single differential sgRNAs between light-dark (LD) cycle and high light (L300)

Related to Figure 5 ('fitness between L300 and L100) and Supplemental Figure 
'fitness between L300 and LD', it is useful to explore also differential sgRNAs 
where only 1 sgRNA per gene and cluster was different. The rationale is that 
some genes are known to be required for LD survival/regulation and should have a
condition-dependent effect on fitness. In other words several genes are known to 
be essential for growth under LD conditions but not under constant light. Globally,
it can be seen from Figure 2 (clustering) that only few sgRNAs are very different
between LD and L300, and they don't form a distinct cluster. The result from this 
analysis is similar, only few single sgRNAs fall within the currently applied 
threshold of -3 $\geq$ dF $\geq$ 3.


```{r}
# Exploring single sgRNA differences between LD and L300
df_LD_single_sgRNA <- df %>% 
  
  # select conditions for comparison
  filter(condition %in% c("LD", "L300"), induction == "i", 
    timepoint == 0, cluster != 5) %>%
  
  # optional filter for sgRNAs that have 1 member per cluster
  group_by(cluster, sgRNA_short) %>% filter(length(sgRNA_index) == 2) %>% 
  
  # filter by highest fitness difference between sgRNA of two conditions
  # genes with lower fitness under LD (dF = L300 - LD) have higher dF
  group_by(cluster, sgRNA) %>% summarise(
    diff_fitness_score = fitness_score[1]-fitness_score[2],
    Process.abbr = unique(Process.abbr)
  ) %>% 
  
  # group by cluster and sort by fitness score for top n filtering
  group_by(cluster) %>% arrange(cluster, desc(diff_fitness_score))
```



```{r}
plot_diff_fitness_LD_single <- xyplot(diff_fitness_score ~ factor(Process.abbr) | factor(cluster), 
  df_LD_single_sgRNA, group = between(diff_fitness_score, -3, 3),
  xlab = "", ylab = "dF (L300-LD)",
  par.settings = custom_lattice, type = "p", pch = 19, as.table = TRUE, 
  col = c("#D33F6A", "#00989D"),
  scales = list(alternating = FALSE, x = list(rot = 45, cex = 0.65)), 
  ylim = c(-6, 6), between = list(x = 0.5, y = 0.5),
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.abline(h = c(-3, 3), lty = 2, lwd = 1, col = grey(0.5))
    panel.stripplot(x, y, jitter.data = TRUE, amount = 0.2, 
      alpha = 0.6, horizontal = FALSE, ...)
    panel.text(1, 4, pos = 4, col = grey(0.5),
      labels = paste0(sum(y <= -3 | y >= 3, na.rm = TRUE), " out of ", length(y), " genes"))
  }
)

df_LD_single_sgRNA <- df_LD_single_sgRNA %>% 
  filter(!between(diff_fitness_score, -3, 3)) %>% 
  pull(sgRNA)


plot_top_diff_LD_single <- xyplot(log2FoldChange ~ generations | paste0(cluster, "  ", sgRNA_short), 
  df %>% filter(sgRNA %in% df_LD_single_sgRNA, 
    induction == "i", condition %in% c("LD", "L300")),
  as.table = TRUE, groups = condition, 
  par.settings = {cust = custom_lattice;
    cust$superpose.polygon$col = c("#00989D", "#D33F6A"); cust}, 
  type = "l", layout = c(6, 4), 
  scales = list(alternating = FALSE, cex = 0.8),
  ylim = c(-10, 10), xlim = c(0, 17),
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.key(c("LD", "L300"), points = FALSE, col = c("#D33F6A", "#00989D"),
      lines = TRUE, cex = 0.7, corner = c(0.05, 0.95), ...)
    panel.abline(h = 0, lty = 2, lwd = 1.5, col = grey(0.5))
    panel.xyarea(x, y, origin = 0, alpha = 0.6, ...)
  }
)
```



```{r, fig.width = 5, fig.height = 8}
print(plot_diff_fitness_LD_single, position = c(0, 0.59, 1, 1), more = TRUE)
print(plot_top_diff_LD_single, position = c(0, 0, 1, 0.64))
grid.text(label = c("A", "B"), x = c(0.03, 0.03), 
  y = c(0.98, 0.59), gp = gpar(cex = 1.3))
```

```{r, results = 'hide', include = FALSE}
svg("../figures/supplemental/Supplemental_figure_fitness_LD_singles.svg", width = 5, height = 8)
print(plot_diff_fitness_LD_single, position = c(0, 0.59, 1, 1), more = TRUE)
print(plot_top_diff_LD_single, position = c(0, 0, 1, 0.64))
grid.text(label = c("A", "B"), x = c(0.03, 0.03), 
  y = c(0.98, 0.59), gp = gpar(cex = 1.3))
dev.off()
```


## Step 6: Enrichment of sgRNAs related to lactate tolerance

In a second set of enrichment/depletion experiments, the sgRNA mutant library
was grown in a 'turbidostat' continuous cultivation with the presence of L-lactate.
Lactate is an important industrial chemical that could be used for poly-lactic acid
(PLA) production. PLA is a potential replacement for conventional fossil-fuel based
plastics. Selecting strains that are more tolerant towards higher concentration of
lactate in the cultivation medium is one of the challenges in biobased lactate production.
To study enrichment (or depletion) of more tolerant (or less tolerant) strains towards
lactate, cells were cultivated in presence of lactate and samples were taken 
after 16 and 32 days. Controls included the uninduced sgRNA mutant library, and an 
sgRNA mutant library grown in presence of equimolar concentration of sodium chloride
(NaCl).

To find genes that are responsible for higher tolerance to lactate, sgRNAs with
enrichment specifically for the lactate but not the sodium chloride condition were
filtered. The volcano plot shows enrichment of 78 sgRNAs under lactate after 32 d,
(threshold: log2 FC $\geq$ 2, -log10 p-value $\geq$ 20), while only 8 sgRNAs were enriched
in the NaCl control. Of these 78 sgRNAs, several were targeting the same gene
giving those targets more confidence compared to single hit sgRNAs.


```{r,  fig.width = 6, fig.height = 2.5, warning = FALSE}
# volcanoplot with potential boundaries for enriched sgRNAs
plot_lactate_volcano <- df %>% filter(condition %in%  c("LAC", "NACL") & timepoint > 8) %>% 
  filter(!is.na(log2FoldChange)) %>%
  
  xyplot(-log10(padj) ~ log2FoldChange | 
      paste0(condition, "  ", timepoint, " d") %>% factor(., unique(.)[c(2,3,1,4)]), ., 
    as.table = TRUE, groups = induction, layout = c(4, 1),
    # groups = read.fraction.mean < 1e-05,
    par.settings = custom.lattice, 
    xlab = bquote(log[2] ~ "FC"), ylab = bquote(-log[10] ~ "p-value"),
    col = c("#D33F6A", "#00989D"),
    cex = 0.2, pch=19, between = list(x = 0.5, y = 0.5),
    scales = list(alternating = FALSE),
    ylim = c(- 20, 200), xlim = c(-10, 10),
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
      panel.quadrants(x, y, h = 20, v = 2, labels = "events")
      panel.key(c("induced", "uninduced"), col = c("#D33F6A", "#00989D"), pch = 19, corner = c(0.9, 0.7))
    }
  )

print(plot_lactate_volcano)
```


```{r}
# filter most enriched sgRNAs according to pvalue and log FC boundaries
candidates <- filter(df, condition %in% "LAC", induction == "i",
  log2FoldChange > 2, log10(padj) <= -20) %>%
  pull(sgRNA) %>% unique

# check which ones fall into same criteria for NACL control ('false positives')
falsepos <- filter(df, condition %in% "NACL", 
  log2FoldChange > 2 & log10(padj) <= -20) %>% 
  pull(sgRNA) %>% unique

# no overlap between Lactate and NaCl enriched sgRNAs
candidates %in% falsepos
```


```{r}
# generate subset df with candidate sgRNAs only
df_lac <- filter(df, sgRNA %in% candidates & condition %in% c("NACL", "LAC"))
head(df_lac)
```



```{r}
# subset data according to 1 or 2 sgRNA per gene enriched
df_selected_fitness <- df_lac %>% 
  
  # consider only LAC, induced
  group_by(sgRNA_short) %>% 
  filter(condition == "LAC", induction == "i") %>%
  
  # summarise average fitness and number sgRNAs per gene
  summarise(
    average_fitness = mean(unique(fitness_score), na.rm =TRUE),
    Process = unique(Process.abbr),
    sgRNAs = length(unique(sgRNA_index))
  ) %>% arrange(Process)

head(df_selected_fitness)
```

#### Supplemental: Genes with only 1 sgRNA enriched under lactate

```{r, fig.width = 8, fig.height = 8, warning = FALSE}
plot_1sgRNAs <- xyplot(log2FoldChange ~ generations | 
    factor(sgRNA_short, arrange(df_lac, Process.abbr) %>% 
      pull(sgRNA_short) %>% unique),
  df_lac %>% group_by(condition, sgRNA_short) %>%
  filter(condition == "LAC", induction == "i", length(sgRNA_index) == 6), 
  auto.key = list(columns = 4, points = FALSE, lines = TRUE),
  as.table = TRUE, groups = Process.abbr, ylab = bquote(log[2] ~ "FC"),
  par.settings = custom.lattice, type = "p",
  scales = list(alternating = FALSE, cex = 0.8),
  ylim = c(-10, 15), xlim = c(0, 30.5), # c(-7, 1)
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.xyarea(x[1:3], y[1:3], border = NA, alpha = 0.7, origin = 0, ...)
    panel.text(0, 10, cex = 0.6, pos = 4, col = grey(0.4), # -4
      paste0("F = ", round(filter(df_selected_fitness, sgRNAs == 1)[panel.number(), 2], 2)))
  }
) +
as.layer(
  xyplot(log2FoldChange ~ generations | 
    factor(sgRNA_short, arrange(df_lac, Process.abbr)
      %>% pull(sgRNA_short) %>% unique),
    df_lac %>% group_by(condition, sgRNA_short) %>%
      filter(condition == "NACL", induction == "i", length(sgRNA_index) == 3),
    type = "l", groups = sgRNA, as.table = TRUE,
    panel = function(x, y, ...) {
      panel.xyarea(x, y, col.line = grey(0.5, 0.5), border = NA, origin = 0, ...)
    }
  )
)

# plot genes with 1 sgRNA per gene only
print(plot_1sgRNAs)
```

```{r, results = 'hide', include = FALSE}
svg("../figures/supplemental/Supplemental_figure_LAC_enrichment_1sgRNA.svg", width = 8, height = 6)
print(plot_1sgRNAs)
dev.off()
```

----------

**Supplemental Figure. Enrichment under lactate with only 1 sgRNA.**
Genes with 1 sgRNA enriched when lactate was present in culture medium. Depicted is 
the log 2 fold change (log2 FC) over number of generations the cells were cultivated
in a turbidostat bioreactor. Colored area: sgRNA in presence of lactate color-coded 
by cyanobase functional category, grey area: sgRNA in presence of sodium chloride. 
F, fitness score for sgRNA in presence of lactate. The fitness score is positive
for enrichment and negative for depletion of sgRNAs.

----------

The same figure was generated for genes with 2 sgRNAs enriched. This is used in 
Figure 5.

```{r}
plot_2sgRNAs <- xyplot(log2FoldChange ~ generations | 
  factor(sgRNA_short, arrange(df_lac, Process.abbr) %>% 
    pull(sgRNA_short) %>% unique),
  df_lac %>% group_by(condition, sgRNA_short) %>%
    filter(condition == "LAC", induction == "i", length(sgRNA_index) == 12), 
  auto.key = list(columns = 3, points = FALSE, lines = TRUE), layout = c(4, 2),
  as.table = TRUE, groups = Process.abbr, ylab = bquote(log[2] ~ "FC"),
  par.settings = custom.lattice, 
  between = list(x = 0.5, y = 0.5),
  scales = list(alternating = FALSE, cex = 0.8),
  ylim = c(-10, 10), xlim = c(0, 30.5),
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.xyarea(x[1:3], y[1:3], border = NA, alpha = 0.5, origin = 0, ...)
    panel.xyarea(x[4:6], y[4:6], border = NA, alpha = 0.5, origin = 0, ...)
    panel.text(0, 8, cex = 0.7, pos = 4, col = grey(0.4),  # -4
      paste0("F = ", round(filter(df_selected_fitness, sgRNAs == 2)[panel.number(), 2], 2)))
  }
) +
as.layer(
  xyplot(log2FoldChange ~ generations | 
    factor(sgRNA_short, arrange(df_lac, Process.abbr)
      %>% pull(sgRNA_short) %>% unique),
    df_lac %>% group_by(condition, sgRNA_short) %>%
      filter(condition == "NACL", induction == "i", length(sgRNA_index) == 6),
    type = "l", groups = sgRNA, as.table = TRUE,
    panel = function(x, y, ...) {
      panel.xyarea(x, y, col.line = grey(0.5, 0.5), border = NA, origin = 0, ...)
    }
  )
)
```

----------

#### Growth advantage of selected knock out strains

Based on the specific enrichment of sgRNAs under lactate, *knock-down
strains of selected genes* were made and cultivated separately in batch setup.
The genes chosen were the eight dual-sgRNA enriched genes from Figure 5 
(*sll1496*, *aroH*, *spoT*, *ilvA*, *sll1712*, *asd*, *gltX*, *slr2070*), and
the single sgRNA enriched gene *bcp2*. Knockdown of that gene showed exceptionally 
high fitness improvevent. Cultivations included a negative control 
(sgRNA against neutral site 'NT0'). 

To determine differences in average growth rate $\mu$,
specific growth rates were calculated in a 5 h sliding window (step size 1 h) from 
cultivation time point 0 to 80 h. This period covered the initial not light-limited
growth phase for which most strains increased in OD 720 nm from 0.05 to 0.5.
The average growth rate was then calculated as mean +/- standard deviation of all 
specific growth rates from sliding window over time.


```{r, include = FALSE}
# CULTIVATIONS
#-------------------------
# 20190815_MC1:
# 1 and 2: NT0 (control strain)
# 3 and 4: sll1496
# 5 and 6: aroH
# 7 and 8: spoT

# 20190815_MC2:
# 1 and 2: NT0 (control strain)
# 3 and 4: ilvA (tube No. 4 might be contaminated)
  # 5 and 6: sll1712
# 7 and 8: bcp2

# 20190826_MC4:
# 1 and 2: NT0 (control strain)
# 3 and 4: asd
# 5 and 6: gltX
# 7 and 8: slr2070
```


```{r, message = FALSE, fig.width = 3, fig.height = 3, warning = FALSE}
# load cultivation data, OD680 and 720 for 2 example cultivations
plot_knockouts_OD <- bind_rows(
    read_csv("../raw_data/20190815_MC1_measurements.csv"),
    read_csv("../raw_data/20190815_MC2_measurements.csv"),
    .id = "cultivation"
  ) %>%
  
  # filter extensively for only NT0 control, bcp2 and aroH
  filter(
    between(batchtime_h, 0, 100), od_led == 720,
    (cultivation == 1 & channel_id %in% c(5,6)) | 
    (cultivation == 2 & channel_id %in% c(1,2,7,8))
  ) %>%
  
  mutate(strain = NA) %>%
  mutate_cond(cultivation == 1 & channel_id %in% c(5,6), strain = "aroH") %>%
  mutate_cond(cultivation == 2 & channel_id %in% c(1,2), strain = "NT0") %>%
  mutate_cond(cultivation == 2 & channel_id %in% c(7,8), strain = "bcp2") %>%
  
  # plot
  xyplot(od_corr ~ batchtime_h, .,
    group = factor(strain, unique(strain)[c(2,3,1)]), 
    xlab = "time [h]", ylab = bquote(OD['720 nm']),
    as.table = TRUE, par.settings = custom.lattice,
    pch = 19, cex = 0.15, xlim = c(0, 100), 
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.xyplot(x, y, ...)
      panel.key(c("NT0", "bcp2", "aroH"), points = FALSE, 
        lines = TRUE, lwd = 1.5, cex = 0.65)
    }
  )
  
print(plot_knockouts_OD)
```


```{r, message = FALSE, fig.width = 6, fig.height = 3}
# load cultivation data, in this case growth rate over time
plot_knockouts_mu <- read_csv("../raw_data/growth_rate_knockouts.csv") %>%

  # rename column and filter for certain time window
  rename(growth_rate = value) %>%
  filter(between(batchtime_h, 5, 80)) %>%
  
  # remove extra NT0 control cultivations (keep only 1)
  filter(!(strain == "NT0" & cultivation %in% c("20190815_MC1", "20190826_MC4"))) %>%
  
  # summarize all growth rates into average growth rate per replicate
  group_by(strain, replicate) %>% 
  summarize(mean_growth_rate = mean(growth_rate)) %>%
  
  # remove 1 faulty replicate of ilvA
  mutate_cond((strain == "ilvA" & replicate == 2), mean_growth_rate = 0.03142573) %>%
  
  # plot
  xyplot(mean_growth_rate ~ factor(strain, unique(strain)[c(6,2,9,8,10,4,7,5,1,3)]), .,
    xlab = "strain", ylab = bquote(mu ~ h^-1),
    as.table = TRUE, par.settings = custom.lattice, col = grey(0.2),
    fill = rep(c("white", grey(0.9), grey(0.7)), c(1,7,2)),
    scales = list(alternating = FALSE, x = list(rot = 30, cex = 0.7)), ylim = c(0, 0.045), lwd = 1.2,
    panel = function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.barplot(x, y, ewidth = 0.3, ...)
      panel.pvalue(x, y, symbol = TRUE, cex_symbol = 1.2, alternative = "greater",
        col = grey(0.2), offset = 0.2, verbose = FALSE)
    }
  )

print(plot_knockouts_mu)
```

----------

As a final part of lactate tolerance analysis and Figure 5 in general, absorption 
spectra of selected strains with higher tolerance were obtained. The data contains
2 biological replicates for each strain (excluding asd, but including bcp2).

```{r, message = FALSE, fig.width = 6, fig.height = 3}
# load data
df_abs <- read_csv("../raw_data/abs_spectrum_lactate.csv") %>%
  
  # reshape to long format
  gather(strain, absorption, NT0:NT0_no_lactate) %>%
  
  # filter for most interesting
  filter(strain %in% c("NT0", "bcp2", "aroH", "ilvA", "sll1496", "gltX")) %>%
  
  # reshape strain to factor
  mutate(strain = factor(strain, c("NT0", "bcp2", "aroH", "ilvA", "sll1496", "gltX")))
  
  
# plot absorption spectra
plot_lac_spectra_1 <- xyplot(absorption ~ wavelength_nm, df_abs, groups = strain,
  par.settings = custom.lattice, type = "l",
  #auto.key = list(columns = 4, points = FALSE, lines = TRUE, cex = 0.7),
  ylim = c(0.8, 2.4), xlim = c(350, 800),
  xlab = "wavelength [nm]", ylab = "absorption [a.u.]",
  lwd = 2, scales = list(alternating = FALSE), as.table = TRUE,
  panel=function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.xyplot(x, y, ...)
    panel.arrows(c(490, 630, 680), rep(2.25, 3), c(490, 630, 680), 
      rep(2.15, 3), length = 0.05, col = grey(0.3))
    panel.text(c(490, 630, 680), 2.3, c("CT", "PC", "CA"), 
      cex = 0.6, col = grey(0.3))
    panel.key(labels = levels(df_abs$strain), points = FALSE, 
      lines = TRUE, cex = 0.7, corner = c(0.01, 0.05))
  }
)

print(plot_lac_spectra_1)
```


```{r, message = FALSE, fig.width = 6, fig.height = 3}
# calculate OD ratios for chl A, phycocyanin, and carotenoids, 
# according to Schulze 2011
plot_lac_spectra_2 <- df_abs %>% 
  
  # filter for absoprtion peak wavelengths for 
  # carotenoids (490), phycocyanin (630), chlorophyll A (680)
  filter(wavelength_nm %in% c(490, 630, 680)) %>%
  
  # add pigment description
  group_by(strain, replicate) %>%
  mutate(pigment = c("carotenoids", "phycocyanin", "chlorophyll A")) %>%
  
  # plot ratios
  xyplot(absorption ~ strain | factor(pigment, unique(pigment)[3:1]), ., 
    col = custom.lattice()$superpose.line$col,
    par.settings = custom.lattice, lwd = 2, pch = 19,
    layout = c(3, 1), xlab = "", ylab = "",
    scales = list(alternating = FALSE, x = list(rot = 30, cex = 0.65)), 
    as.table = TRUE,
    panel=function(x, y, ...) {
      panel.grid(h = -1, v = -1, col = grey(0.9))
      panel.errbars(x, y, ewidth = 0, ...)
    }
  )

print(plot_lac_spectra_2)

```


----------

#### Figure 5: Genes with 2 sgRNAs enriched under lactate

```{r, fig.width = 6, fig.height = 10}
print(plot_lactate_volcano, position = c(0, 0.76, 1, 1), more = TRUE)
print(plot_2sgRNAs, position = c(0.01, 0.45, 1, 0.79), more = TRUE)
print(plot_knockouts_mu, position = c(0, 0.22, 0.63, 0.49), more = TRUE)
print(plot_knockouts_OD, position = c(0.6, 0.24, 1, 0.49), more = TRUE)
print(plot_lac_spectra_1, position = c(0, 0, 0.42, 0.25), more = TRUE)
print(plot_lac_spectra_2, position = c(0.36, -0.01, 1, 0.25))
grid.text(label = c("a", "b", "c", "d", "e", "f"), gp = gpar(cex = 1.2),
  x = c(0.03, 0.03, 0.03, 0.6, 0.03, 0.42), 
  y = c(0.98, 0.77, 0.45, 0.45, 0.22, 0.22))
```


```{r, results = 'hide', include = FALSE}
svg("../figures/main/Figure5.svg", width = 6, height = 10)
print(plot_lactate_volcano, position = c(0, 0.76, 1, 1), more = TRUE)
print(plot_2sgRNAs, position = c(0.01, 0.45, 1, 0.79), more = TRUE)
print(plot_knockouts_mu, position = c(0, 0.22, 0.63, 0.49), more = TRUE)
print(plot_knockouts_OD, position = c(0.6, 0.24, 1, 0.49), more = TRUE)
print(plot_lac_spectra_1, position = c(0, 0, 0.42, 0.25), more = TRUE)
print(plot_lac_spectra_2, position = c(0.36, -0.01, 1, 0.25))
grid.text(label = c("a", "b", "c", "d", "e", "f"), gp = gpar(cex = 1.2),
  x = c(0.03, 0.03, 0.03, 0.6, 0.03, 0.42), 
  y = c(0.98, 0.77, 0.45, 0.45, 0.22, 0.22))
dev.off()
```

----------

**Figure 5. Enrichment of sgRNAs related to lactate tolerance.**
Strains with improved tolerance to lactate were obtained from cultivation of the sgRNA mutant library
in presence of 150 mM lactate for 16 and 32 days. Controls included an uninduced sgRNA mutant library, 
and a library grown in presence of equimolar concentration of sodium chloride (NACL).
**a** The volcano plot shows enrichment of 78 sgRNAs under lactate after 32 d,
(threshold: log2 FC $\geq$ 2, -log10 p-value $\geq$ 20), while only 8 sgRNAs were enriched
in the NaCl control.
**b** Top 8 (out of 9) genes with both sgRNAs specifically enriched under presence of lactate 
but not sodium chloride. Quantification of _asd_ sgRNA 1 for NaCl control, 32 d, was missing.
**c** Mean growth rate of selected knock-down strains (n = 2) over the first 80 h of cultivation. One replicate of _ilvA_ was removed due to contamination (# symbol).
**d** Example of growth advantage of sgRNA mutants _bcp2_ and _aroH_ over control (NT0).
**e** Absorption spectra of five fastest growing sgRNA mutants and control (NT0). 
Arrows mark absoprtion maxima for pigments. CT - carotenoids, PC - phycocyanin, CA - chlorophyll A.
**f** Relative pigment absorption for carotenoids, phycocyanin and chlorophyll A for the five
fastest growing mutants in comparison to control (NT0).

----------

#### Supplemental: Genes with 1 or 2 sgRNAs _depleted_ under lactate

----------

In this step, sgRNAs are filtered for _depleted_ and not _enriched_ clones. The
reasoning behind this strategy is that genes specifically depleted under lactate
may contribute to increased tolerance/cell fitness, and hence could be targets
for over expression instead of knock-out. SgRNAs that have low fitness score under
lactate _but not in sodium chloride_ could be specific transporters for lactate. 
The analysis applied here is identical to the above described analysis of enriched sgRNAs.


```{r}
# filter for sgRNAs different between LAC and NACL
candidates_depl <- filter(df, condition %in% c("NACL", "LAC"), induction == "i", timepoint == 0) %>%

  # optional filter for sgRNAs that have both sgRNAs detected in NACL and LAC
  group_by(sgRNA_short) %>% filter(length(sgRNA_index) == 4) %>%

  # filter by highest fitness diff between sgRNA of two conditions (NACL-LAC)
  # higher for stronger LAC depletion
  group_by(sgRNA) %>% summarise(diff_fitness_score = diff(fitness_score)) %>%

  # sort by differential fitness score and pull out candidates
  arrange(desc(diff_fitness_score)) %>% slice(1:200) %>% pull(sgRNA)
```


```{r}
# generate subset df with candidate sgRNAs only
df_lac_depl <- filter(df, sgRNA %in% candidates_depl, condition %in% c("NACL", "LAC"))
head(df_lac_depl)
```


```{r}
# subset data according to 1 or 2 sgRNA per gene enriched
df_selected_fitness <- df_lac_depl %>% group_by(sgRNA_short) %>% 
  filter(condition == "LAC", induction == "i") %>% 
  summarise(
    average_fitness = mean(unique(fitness_score), na.rm =TRUE),
    Process = unique(Process.abbr),
    sgRNAs = length(unique(sgRNA_index))
  ) %>% 
  
  # filter out genes with small changes in average fitness
  filter(average_fitness <= -1) %>% arrange(Process)

head(df_selected_fitness)

# remove those also in parent df
df_lac_depl <- filter(df_lac_depl, sgRNA_short %in% df_selected_fitness$sgRNA_short)
```



```{r}
plot_depl_1sgRNAs <- xyplot(log2FoldChange ~ generations | 
    factor(sgRNA_short, arrange(df_lac_depl, Process.abbr) %>% 
      pull(sgRNA_short) %>% unique),
  df_lac_depl %>% group_by(condition, sgRNA_short) %>%
  filter(condition == "LAC", induction == "i", length(sgRNA_index) == 6), 
  auto.key = list(columns = 4, points = FALSE, lines = TRUE),
  as.table = TRUE, groups = Process.abbr, ylab = bquote(log[2] ~ "FC"),
  par.settings = custom.lattice, type = "p",
  scales = list(alternating = FALSE, cex = 0.8),
  ylim = c(-6, 6), xlim = c(0, 30.5), # c(-7, 1)
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.xyarea(x[1:3], y[1:3], border = NA, alpha = 0.7, origin = 0, ...)
    panel.text(0, 4.5, cex = 0.6, pos = 4, col = grey(0.4), # -4
      paste0("F = ", round(filter(df_selected_fitness, sgRNAs == 1)[panel.number(), 2], 2)))
  }
) +
as.layer(
  xyplot(log2FoldChange ~ generations | 
    factor(sgRNA_short, arrange(df_lac_depl, Process.abbr)
      %>% pull(sgRNA_short) %>% unique),
    df_lac_depl %>% group_by(condition, sgRNA_short) %>%
      filter(condition == "NACL", induction == "i", length(sgRNA_index) == 3),
    type = "l", groups = sgRNA, as.table = TRUE,
    panel = function(x, y, ...) {
      panel.xyarea(x, y, col.line = grey(0.5, 0.5), border = NA, origin = 0, ...)
    }
  )
)
```


```{r}
plot_depl_2sgRNAs <- xyplot(log2FoldChange ~ generations | 
  factor(sgRNA_short, arrange(df_lac_depl, Process.abbr) %>% 
    pull(sgRNA_short) %>% unique),
  df_lac_depl %>% group_by(condition, sgRNA_short) %>%
    filter(condition == "LAC", induction == "i", length(sgRNA_index) == 12), 
  auto.key = list(columns = 3, points = FALSE, lines = TRUE), layout = c(6, 1),
  as.table = TRUE, groups = Process.abbr, ylab = bquote(log[2] ~ "FC"),
  par.settings = custom.lattice, 
  scales = list(alternating = FALSE, cex = 0.8),
  ylim = c(-6, 6), xlim = c(0, 30.5), 
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.xyarea(x[1:3], y[1:3], border = NA, alpha = 0.5, origin = 0, ...)
    panel.xyarea(x[4:6], y[4:6], border = NA, alpha = 0.5, origin = 0, ...)
    panel.text(0, 4.5, cex = 0.7, pos = 4, col = grey(0.4), 
      paste0("F = ", round(filter(df_selected_fitness, sgRNAs == 2)[panel.number(), 2], 2)))
  }
) +
as.layer(
  xyplot(log2FoldChange ~ generations | 
    factor(sgRNA_short, arrange(df_lac_depl, Process.abbr)
      %>% pull(sgRNA_short) %>% unique),
    df_lac_depl %>% group_by(condition, sgRNA_short) %>%
      filter(condition == "NACL", induction == "i", length(sgRNA_index) == 6),
    type = "l", groups = sgRNA, as.table = TRUE,
    panel = function(x, y, ...) {
      panel.xyarea(x, y, col.line = grey(0.5, 0.5), border = NA, origin = 0, ...)
    }
  )
)
```


```{r, fig.width = 8, fig.height = 12, warning = FALSE}
print(plot_depl_1sgRNAs, position = c(0, 0.21, 1, 1), more = TRUE)
print(plot_depl_2sgRNAs, position = c(0, 0, 1, 0.22))
grid.text(label = c("a", "b"), x = c(0.03, 0.03), y = c(0.98, 0.22), gp = gpar(cex = 1.2))
```


```{r, results = 'hide', include = FALSE}
svg("../figures/supplemental/Supplemental_figure_LAC_depletion.svg", width = 8, height = 12)
print(plot_depl_1sgRNAs, position = c(0, 0.21, 1, 1), more = TRUE)
print(plot_depl_2sgRNAs, position = c(0, 0, 1, 0.22))
grid.text(label = c("a", "b"), x = c(0.03, 0.03), y = c(0.98, 0.22), gp = gpar(cex = 1.2))
dev.off()
```

----------

**Supplemental Figure. Depletion of 1 or 2 sgRNAs per gene under lactate.**
Specific depletion of sgRNA mutants related to lactate tolerance 
was tested by selecting the top 200 of all sgRNAs with lower fitness under lactate, 
but not sodium chloride addition. Of those, only sgRNAs with fitness score F $\leq$ -1
were selected.
**a** Genes with only 1 sgRNA depleted when lactate was present in culture medium. 
**b** Genes with 2 sgRNAs depleted when lactate was present in culture medium. 
Depicted is the log 2 fold change (log2 FC) over number of generations the cells were cultivated
in a turbidostat bioreactor. Colored area: sgRNA in presence of lactate color-coded 
by cyanobase functional category, grey area: sgRNA in presence of sodium chloride. 
F, fitness score for sgRNA in presence of lactate. The fitness score is positive
for enrichment and negative for depletion of sgRNAs.

----------


#### Step 7: Save processed data to disk

The last step is to save the processed data frame to disk.
This table is identical to the result of the previous pipeline ('df_annotated')
but contains 1 additional column with cluster annotation.


```{r}
# merge df containing all genes with df containing noncoding RNAs
df <- bind_rows(df, df_ncRNA)
save(df, file = "../processed_data/CRISPRi_library_df_cluster.Rdata")
write_csv(df, "../processed_data/CRISPRi_library_df_cluster.csv")
```
