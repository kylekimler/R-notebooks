---
title: "Constraints for an *R. eutropha* resource allocation model"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_notebook: 
    theme: spacelab
    toc: yes
---


## Description

This R notebook is a bioinformatics pipeline to **collect constraints for a genome scale, resource allocation model** in the chemolithoautotroph *Ralstonia eutropha* (a.k.a. *Cupriavidus necator*).

A resource allocation model can be coarse-grained (few symbolic reactions) or have genome scale detail (all known biochemical reactions and their associated genes). However, both types of models need to be constrained by a set of parameters to make realistic predictions. Depending on the model frame work, constraints can be equality constraints (example: turnover number of an enzyme E kcat<sub>E</sub> = 100 s<sup>-1</sup>), or inequality constraints (0 s<sup>-1</sup> <= kcat<sub>E</sub> <= 100 s<sup>-1</sup>). 

This notebook has the purpose to collect **constant and growth-rate dependent constraints** as they are used in [RBA models](https://sysbioinra.github.io/RBApy/). In RBApy, apparent enzyme efficiencies (_kapp_), protein abundance, molecular machine abundance (protein/macromolecule complexes), and fluxes can be constrained. RBApy has the following possibilities for custom constraints.

- constants (example: `A = 0.1`)
- linear relationship, e.g. with growth rate µ (example: `B = 2 * µ + 0.1`)
- Michaelis-Menthen like kinetics for kapp (example: `kapp = kcat * [S] / ([S] + Km)`)

Different types of data were collected to constrain at least two major determinants of a resource allocation model.

1. **turnover number `kcat`**: Organism-specific values can be downloaded from enzyme data base BRENDA. In this case we use a precompiled file `max_KCAT.txt` from another resource allocation algorithm, [GECKO](https://github.com/SysBioChalmers/GECKO/tree/master/databases)
2. **protein abundance**: protein abundance was determined with mass spcetrometry globally for *R. eutropha* using different growth rates and carbon sources. This data will be used to estimate and constrain enzyme abundance, and non-enzyme protein abundance.


## Libraries

```{r, message = FALSE}
# loading libraries
library(lattice)
library(latticeExtra)
library(latticetools)
library(tidyverse)
library(stringi)
```

## Turnover numbers

### Import data from GECKO

The precompiled turnover numbers were downloaded from [GECKO](https://github.com/SysBioChalmers/GECKO/tree/master/databases) and apparently created Aug 16, 2018. The table contains all possible kcat values per enzyme class. It also contains a rudimentary phylogenetic classification (bacteria, archae, eukaryota, and so on) that can be used to strip matching kcat values with regular expressions.

```{r, message = FALSE, warning = FALSE}
# load kcat data
df_kcat <- read_tsv("../data/GECKO_20200505_max_KCAT.tsv", col_names = FALSE)[-5] %>%
  set_names(c("EC_number", "substrate", "organism", "kcat"))

# preview data
head(df_kcat)
```

### Overview of bacterial kcat values

We trim the dataset to include only `bacteria`. Then we extract species annotation using regular expressions, and plot an examplary subset of the data. The goal here is to test if the kcat values are normal-distributed, if there are outliers, and how common outliers are for specific species or EC numbers. These precautions are taken to make sure that the (maximum) kcat values we select are representative, and not extreme measurements that are unlikely to exist under unphysiological conditions (most values in BRENDA are inferred from *in vitro* measurements though).

```{r}
# split organism column in three
df_kcat <- df_kcat %>% separate(organism, c("species", "phylogeny", "org_id"), sep = "//") %>%
  
  # replace placeholder star with NA
  mutate_all(function(x) na_if(x, "*")) %>%
  
  # clip 'EC' away from EC number
  mutate(EC_number = gsub("^EC", "", EC_number)) %>%
  
  # filter for 'bacteria' key word
  filter(grepl('bacteria', phylogeny))

head(df_kcat)
```

Now that the data is in a reasonable shape, `kcat` value distributions can be plotted broken down by EC number, substrate or organism.

```{r, fig.width = 9, fig.height = 7}
df_kcat <- df_kcat %>% 
  
  # determine number of values per reactions
  group_by(EC_number) %>%
  mutate(n_kcat_values = length(kcat))
  
# plot
histogram(~ log10(kcat) | EC_number, 
  filter(df_kcat, n_kcat_values >= 30),
  groups = species, breaks = seq(-5, 5, 0.5), 
  as.table = TRUE, between = list(x = 0.5, y = 0.5),
  par.settings = custom.lattice, border = "white",
  scales =list(alternating = FALSE), ylim = c(-5, 60),
  panel = function(x, ...){
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, ...)
  }
)
```

It becomes quite clear that some of the kcat value distributions contain extreme outliers (1 to 2 orders of magnitude). Extreme values are biologically possible because the kcat can be different for different substrates or organism. Nevertheless it is wise to focus on the majority vote, and exclude kcat values that deviate too much. We filter the 5 % upper and lower quantile if more than 5 kcat values are available per reaction.

```{r, fig.width = 9, fig.height = 7}
df_kcat <- df_kcat %>%
  
  # filter the central 90 % of values (discard upper and lower 5 %)
  filter(!(n_kcat_values >= 5 & 
    (kcat < quantile(kcat, 0.05) | kcat > quantile(kcat, 0.95))
  ))

# plot
histogram(~ log10(kcat) | EC_number, 
  filter(df_kcat, n_kcat_values >= 30),
  groups = species, breaks = seq(-5, 5, 0.5), 
  as.table = TRUE, between = list(x = 0.5, y = 0.5),
  par.settings = custom.lattice, border = "white",
  scales =list(alternating = FALSE), ylim = c(-5, 60),
  panel = function(x, ...){
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.histogram(x, ...)
  }
)
```

### Function to retrieve kcat values as model constraints

The last step is to devise a function that will match annotated EC numbers from the metabolic model with kcat values from the BRENDA database. It needs to perform the following steps sequentially. For each enzyme E, 

1. look up possible EC numbers in data base
2. if a *Ralstonia*/*Cupriavidus* entry is available, choose it
3. else look up *Burkholderiales* and take the median of the subset
4. else look up *betaproteobacteria* and take the median of the subset
5. else if none of these categories are available, take the median of all

The function is implemented in a versatile self-contained way so that it can be reused and adapated any time.
It takes the following input parameters:

- `kcat_data` - data frame with kcat values (imported directly from GECKO). Needs at least columns 'EC_number', 'species', 'phylogeny', and 'kcat'
- `ec_number` - the EC number to look up
- `species` - the name of the target species
- `phylogeny` - a set of search terms to look up in order of decreasing specificity
- `fun_aggregate` - the function to aggregate a selection of kcat values, like max, mean, median, and so on

```{r}
# main retrieval function
get_kcat <- function(
  ec_number, kcat_data,
  species = NULL, phylogeny = NULL,
  fun_aggregate = median) {
  
  # remove NA kcats from input and filter by EC number
  kcat_data <- kcat_data %>% ungroup %>%
    filter(!is.na(kcat), EC_number %in% ec_number)
  
  # return NA if EC number is not present
  if (nrow(kcat_data) == 0) {
    return(NA)
  }
  
  # filter by species
  index <- FALSE
  if (!is.null(species)) {
    index <- grepl(species, kcat_data[["species"]])
    if (any(index)) kcat_data <- filter(kcat_data, index)
  }
  
  # filter by phylogenetic terms
  if (!is.null(phylogeny) & !any(index)) {
    for (key in phylogeny) {
      index <- grepl(key, kcat_data[["phylogeny"]])
      if (any(index)) kcat_data <- filter(kcat_data, index); break
    }
  }
  
  # aggregate values
  kcat_data %>% pull(kcat) %>% fun_aggregate
}
```

Now let's test function using regular expressions!

```{r}
get_kcat(
  ec_number = "1.1.1.1",
  kcat_data = df_kcat,
  species = "[Cc]upriavidus|[Rr]alstonia",
  phylogeny = c("[Bb]urkholderiales", "[Bb]etaproteobacteria")
)
```

### Retrieve kcat values and export

The final step is to apply the function to each EC number that is present in the model. We retrieve only **full matches**, not partial matches like `1.2.3.-`. We also retrieve the **median kcat values** if several are available. If this appears to be over-constraining a resource allocation model, we could also select the **maximum kcat** instead. We then plot the distribution of `kcat` values on a log10 scale. We can see from the quantiles that the central 75 % of `kcat` values lie between 2.0 and 45.0.

```{r, message = FALSE, warning = FALSE}
# load model reactions
df_model <- read_csv("../data/model_reactions.csv")[-1]
head(df_model)

# retrieve kcat values and add new column to reaction data
df_model$kcat <- sapply(df_model$EC_number, USE.NAMES = FALSE, function(ec_number) {
  # preprocessing ec strings
  ec_number %>% str_replace_all("\\[|\\]|'", "") %>% 
    str_split(", ") %>% unlist %>%
    get_kcat(df_kcat,
      species = "[Cc]upriavidus|[Rr]alstonia", 
      phylogeny = c("[Bb]urkholderiales", "[Bb]etaproteobacteria")
    )
})

# quantiles
df_model$kcat %>% quantile(na.rm = TRUE)

# overview about kcat value distribution
histogram(~ kcat, df_model,
  breaks = seq(-7, 7, 0.25), 
  par.settings = custom.lattice, border = "white",
  scales = list(x = list(log = 10)),
  panel = function(x, ...){
    panel.grid(h = -1, v = -1, col = grey(0.9))
    panel.abline(v = -7:7, col = grey(0.9))
    panel.histogram(x, ...)
  }
)
```

---------

The final step is to export the data frame in a format that is suitable for RBApy input. In this case the format requirements are:

- tab-separated values, no header
- units in `1/h` instead of `1/s` (x 3600)
- reaction ID in column 1, format (`R_`)`ID_enzyme` or `ID_transporter`
- max kcat in column 2
- min kcat in column 3 (backward efficiency, can be identical)
- no NA values (only complete rows)

```{r}
df_model %>%
  select(reaction_id, kcat) %>%
  mutate(reaction_id = paste0("R_", reaction_id, "_enzyme")) %>%
  mutate(kcat = kcat * 3600, kcat_2 = kcat) %>%
  filter(!is.na(kcat)) %>%
  write_tsv("../data/enzyme_efficiency.tsv", col_names = FALSE)
```

